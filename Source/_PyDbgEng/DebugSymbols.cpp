#include "StdAfx.h"
#include "utils.h"

#include "DebugObject.h"
#include "DebugOutput.h"
#include "DebugBreakpoint.h"
#include "DebugControl.h"

#include "DebugSymbols.h"

#include <string>
#include <vector>

#include <boost/python.hpp>
using namespace boost::python;

void CDebugSymbols::Export(void)
{
	enum_<SymbolOption>("SymbolOption")
		.value("CASE_INSENSITIVE",          SymbolOption::OPT_CASE_INSENSITIVE)
		.value("UNDNAME",                   SymbolOption::OPT_UNDNAME)
		.value("DEFERRED_LOADS",            SymbolOption::OPT_DEFERRED_LOADS)
		.value("NO_CPP",                    SymbolOption::OPT_NO_CPP)
		.value("LOAD_LINES",                SymbolOption::OPT_LOAD_LINES)
		.value("OMAP_FIND_NEAREST",         SymbolOption::OPT_OMAP_FIND_NEAREST)
		.value("LOAD_ANYTHING",             SymbolOption::OPT_LOAD_ANYTHING)
		.value("IGNORE_CVREC",              SymbolOption::OPT_IGNORE_CVREC)
		.value("NO_UNQUALIFIED_LOADS",      SymbolOption::OPT_NO_UNQUALIFIED_LOADS)
		.value("FAIL_CRITICAL_ERRORS",      SymbolOption::OPT_FAIL_CRITICAL_ERRORS)
		.value("EXACT_SYMBOLS",             SymbolOption::OPT_EXACT_SYMBOLS)
		.value("ALLOW_ABSOLUTE_SYMBOLS",    SymbolOption::OPT_ALLOW_ABSOLUTE_SYMBOLS)
		.value("IGNORE_NT_SYMPATH",         SymbolOption::OPT_IGNORE_NT_SYMPATH)
		.value("INCLUDE_32BIT_MODULES",     SymbolOption::OPT_INCLUDE_32BIT_MODULES)
		.value("PUBLICS_ONLY",              SymbolOption::OPT_PUBLICS_ONLY)
		.value("NO_PUBLICS",                SymbolOption::OPT_NO_PUBLICS)
		.value("AUTO_PUBLICS",              SymbolOption::OPT_AUTO_PUBLICS)
		.value("NO_IMAGE_SEARCH",           SymbolOption::OPT_NO_IMAGE_SEARCH)
		.value("SECURE",                    SymbolOption::OPT_SECURE)
		.value("NO_PROMPTS",                SymbolOption::OPT_NO_PROMPTS)
		.value("OVERWRITE",                 SymbolOption::OPT_OVERWRITE)
		.value("IGNORE_IMAGEDIR",           SymbolOption::OPT_IGNORE_IMAGEDIR)
		.value("FLAT_DIRECTORY",            SymbolOption::OPT_FLAT_DIRECTORY)
		.value("FAVOR_COMPRESSED",          SymbolOption::OPT_FAVOR_COMPRESSED)
		.value("ALLOW_ZERO_ADDRESS",        SymbolOption::OPT_ALLOW_ZERO_ADDRESS)
		.value("DISABLE_SYMSRV_AUTODETECT", SymbolOption::OPT_DISABLE_SYMSRV_AUTODETECT)
		.value("DEBUG",                     SymbolOption::OPT_DEBUG)
	;

	enum_<TypeOption>("TypeOption")
		.value("DEFAULT",            TypeOption::OPT_TYPE_DEFAULT)
		.value("UNICODE_DISPLAY",    TypeOption::OPT_UNICODE_DISPLAY)
		.value("LONGSTATUS_DISPLAY", TypeOption::OPT_LONGSTATUS_DISPLAY)
		.value("FORCERADIX_OUTPUT",  TypeOption::OPT_FORCERADIX_OUTPUT)
		.value("MATCH_MAXSIZE",      TypeOption::OPT_MATCH_MAXSIZE)
	;

	scope DebugSymbols = class_<CDebugSymbols>("DebugSymbols", no_init)
		.add_property("SymbolOptions", &CDebugSymbols::GetSymbolOptions, &CDebugSymbols::SetSymbolOptions,
			"the engine's global symbol options.")
		.def("AddSymbolOptions", &CDebugSymbols::AddSymbolOptions,
			"turns on some of the engine's global symbol options.")
		.def("RemoveSymbolOptions", &CDebugSymbols::RemoveSymbolOptions,
			"turns off some of the engine's global symbol options.")

		.add_property("TypeOptions", &CDebugSymbols::GetTypeOptions, &CDebugSymbols::SetTypeOptions,
			"the type formatting options for output generated by the engine.")
		.def("AddTypeOptions", &CDebugSymbols::AddTypeOptions,
			"turns on some type formatting options for output generated by the engine.")
		.def("RemoveTypeOptions", &CDebugSymbols::RemoveTypeOptions,
			"turns off some type formatting options for output generated by the engine.")

		.add_property("ImagePath", &CDebugSymbols::GetImagePath, &CDebugSymbols::SetImagePath,
			"The executable image path is used by the engine when searching for executable images.")
		.def("AppendImagePath", &CDebugSymbols::AppendImagePath,
			"append directories to the executable image path.")

		.add_property("SymbolPath", &CDebugSymbols::GetSymbolPath, &CDebugSymbols::SetSymbolPath,
			"The symbol path is used by the engine when searching for debug symbol.")
		.def("AppendSymbolPath", &CDebugSymbols::AppendSymbolPath,
			"append directories to the symbol path.")

		.add_property("SourcePath", &CDebugSymbols::GetSourcePath, &CDebugSymbols::SetSourcePath,
			"The source path is used by the engine when searching for source files.")
		.def("AppendSourcePath", &CDebugSymbols::AppendSourcePath,
			"append directories to the source path.")

		.add_property("LoadedModules", &CDebugSymbols::GetLoadedModules,
			"loaded modules in the current process's module list")
		.add_property("UnloadedModules", &CDebugSymbols::GetUnloadedModules,
			"unloaded modules in the current process's module list.")

		.def("GetModule", &CDebugSymbols::GetModuleByName, ("name", arg("start")=0),
			"search through the target's modules for one with the specified name.")
		.def("GetModule", &CDebugSymbols::GetModuleByOffset, ("offset", arg("start")=0),
			"searches through the target's modules for one whose memory allocation includes the specified location.")

		.def("GetType", &CDebugSymbols::GetTypeByName,
			"return the type ID and module of the specified symbol.")
		.def("GetType", &CDebugSymbols::GetTypeByOffset,
			"the type of the symbol closest to the specified memory location.")

		.def("GetOffsetByName", &CDebugSymbols::GetOffsetByName,
			"the location of a symbol identified by name.")
		.def("GetNameByOffset", &CDebugSymbols::GetNameByOffset, ("offset", arg("delta")=0),
			"the name and displacement of the symbol at the specified location in the target's virtual address space.")

		.def("GetSymbolOffsets", &CDebugSymbols::GetSymbolOffsets,
			"search for symbols whose names match a given pattern.")

		.def("GetSymbols", &CDebugSymbols::GetSymbolsByName,
			"return the symbols whose names match a given pattern.")
		.def("GetSymbols", &CDebugSymbols::GetSymbolsByOffset,
			"returns the symbols which are located at a specified address.")
	;

	class_<CModule>("Module", no_init)
		.add_property("Base", &CModule::GetBase)

		.add_property("ImageName", &CModule::GetImageName, "The name of the executable file, including the extension.")
		.add_property("ModuleName", &CModule::GetModuleName, "Just the file name without the extension.")
		.add_property("LoadedImageName", &CModule::GetLoadedImageName, "The loaded image name.")
		.add_property("SymbolFileName", &CModule::GetSymbolFileName, "The path and name of the symbol file.")
		.add_property("MappedImageName", &CModule::GetMappedImageName, "The mapped image name.")

		.def("GetType", &CModule::GetTypeByName,
			"look up the specified type and return its type ID.")
		.def("Reload", &CModule::Reload,
			"delete the engine's symbol information for the specified module and reload these symbols as needed.")

		.def("__repr__", &CModule::Repr)
	;

	class_<CType>("Type", no_init)
		.add_property("Module", &CType::GetModule, "the module containing the symbol")
		.add_property("Id", &CType::GetId, "the type ID")

		.add_property("Name", &CType::GetName, "name of the type symbol")
		.add_property("Size", &CType::GetSize, "the number of bytes of memory an instance of the type.")

		.add_property("Fields", &CType::GetFields,
			"the type of fields and its offset within a type")

		.def("ReadPhysical", &CType::ReadPhysical,
			"reads the value of a variable from the target computer's physical memory.")
		.def("WritePhysical", &CType::WritePhysical,
			"writes the value of a variable in the target computer's physical memory.")
		.def("OutputPhysical", &CType::OutputPhysical,
			("offset", arg("options")=TypeOption::OPT_TYPE_DEFAULT, arg("target")=CDebugControl::OutputControl::OUTPUT_ALL_CLIENTS),
			"formats the contents of a variable in the target computer's physical memory, and then sends this to the output callbacks.")
		.def("ReadVirtual", &CType::ReadVirtual,
			"reads the value of a variable in the target's virtual memory.")
		.def("WriteVirtual", &CType::WriteVirtual,
			"writes data to the target's virtual address space. The number of bytes written is the size of the specified type.")
		.def("OutputVirtual", &CType::OutputVirtual,
			("offset", arg("options")=TypeOption::OPT_TYPE_DEFAULT, arg("target")=CDebugControl::OutputControl::OUTPUT_ALL_CLIENTS),
			"formats the contents of a variable in the target's virtual memory, and then sends this to the output callbacks.")

		.def("__repr__", &CType::Repr)
	;

	class_<CSymbol>("Symbol", no_init)
		.add_property("Name", &CSymbol::GetName)
		.add_property("ModuleBase", &CSymbol::GetModuleBase,
			"The base address of the module in the target's virtual address space.")
		.add_property("Module", &CSymbol::GetModule)
		.add_property("Id", &CSymbol::GetId,
			"The symbol ID of the symbol.")
		.add_property("Offset", &CSymbol::GetOffset,
			"The location of the symbol in the target's virtual address space.")
		.add_property("Size", &CSymbol::GetSize,
			"The size, in bytes, of the symbol's value.")
		.add_property("TypeId", &CSymbol::GetTypeId,
			"The type ID of the symbol.")
		.add_property("Token", &CSymbol::GetToken,
			"The managed token of the symbol.")
		.add_property("Tag", &CSymbol::GetTag,
			"The symbol tag for the type of the symbol.")
		.add_property("Arg32", &CSymbol::GetArg32,
			"The interpretation of Arg32 depends on the type of the symbol.")
		.add_property("Arg64", &CSymbol::GetArg64,
			"The interpretation of Arg64 depends on the type of the symbol.")
		.def("__repr__", &CSymbol::Repr)
	;
}

const list CDebugSymbols::GetSymbolOptions(void) const
{
	ULONG res;
	Check(m_intf->GetSymbolOptions(&res));

	return utils::FlagsToList(static_cast<SymbolOption>(res), SymbolOption::OPT_CASE_INSENSITIVE, SymbolOption::OPT_DEBUG);
}
void CDebugSymbols::SetSymbolOptions(const list options) const
{
	ULONG res = utils::FlagsFromList<ULONG, SymbolOption>(options);

	Check(m_intf->SetSymbolOptions(res));
}
void CDebugSymbols::AddSymbolOptions(SymbolOption option) const
{
	ULONG res = static_cast<ULONG>(option);

	Check(m_intf->AddSymbolOptions(res));
}
void CDebugSymbols::RemoveSymbolOptions(SymbolOption option) const
{
	ULONG res = static_cast<ULONG>(option);

	Check(m_intf->RemoveSymbolOptions(res));
}

const list CDebugSymbols::GetTypeOptions(void) const
{
	CComQIPtr<IDebugSymbols2> intf(m_intf);

	ULONG res;
	Check(intf->GetTypeOptions(&res));
	return utils::FlagsToList(static_cast<TypeOption>(res), TypeOption::OPT_UNICODE_DISPLAY, TypeOption::OPT_MATCH_MAXSIZE);
}
void CDebugSymbols::SetTypeOptions(const list options) const
{
	CComQIPtr<IDebugSymbols2> intf(m_intf);

	ULONG res = utils::FlagsFromList<ULONG, TypeOption>(options);
	Check(intf->SetTypeOptions(res));
}
void CDebugSymbols::AddTypeOptions(TypeOption option) const
{
	CComQIPtr<IDebugSymbols2> intf(m_intf);

	ULONG res = static_cast<ULONG>(option);
	Check(intf->AddTypeOptions(res));
}
void CDebugSymbols::RemoveTypeOptions(TypeOption option) const
{
	CComQIPtr<IDebugSymbols2> intf(m_intf);

	ULONG res = static_cast<ULONG>(option);
	Check(intf->RemoveTypeOptions(res));
}

const std::string CDebugSymbols::GetImagePath(void) const
{
	char szPath[MAX_PATH_LENGTH];
	ULONG ulSize = _countof(szPath);

	Check(m_intf->GetImagePath(szPath, ulSize, &ulSize));
	return std::string(szPath, ulSize-1);
}

void CDebugSymbols::SetImagePath(const std::string& path) const
{
	Check(m_intf->SetImagePath(path.c_str()));
}

void CDebugSymbols::AppendImagePath(const std::string& path) const
{
	Check(m_intf->AppendImagePath(path.c_str()));
}

const std::string CDebugSymbols::GetSymbolPath(void) const
{
	char szPath[MAX_PATH_LENGTH];
	ULONG ulSize = _countof(szPath);

	Check(m_intf->GetSymbolPath(szPath, ulSize, &ulSize));
	return std::string(szPath, ulSize-1);
}

void CDebugSymbols::SetSymbolPath(const std::string& path) const
{
	Check(m_intf->SetSymbolPath(path.c_str()));
}

void CDebugSymbols::AppendSymbolPath(const std::string& path) const
{
	Check(m_intf->AppendSymbolPath(path.c_str()));
}

const std::string CDebugSymbols::GetSourcePath(void) const
{
	char szPath[MAX_PATH_LENGTH];
	ULONG ulSize = _countof(szPath);

	Check(m_intf->GetSourcePath(szPath, ulSize, &ulSize));
	return std::string(szPath, ulSize-1);
}

void CDebugSymbols::SetSourcePath(const std::string& path) const
{
	Check(m_intf->SetSourcePath(path.c_str()));
}

void CDebugSymbols::AppendSourcePath(const std::string& path) const
{
	Check(m_intf->AppendSourcePath(path.c_str()));
}

const dict CDebugSymbols::GetLoadedModules(void) const
{
	ULONG loaded = 0, unloaded = 0;
	Check(m_intf->GetNumberModules(&loaded, &unloaded));

	dict modules;
	for (ULONG i=0; i<loaded; i++) {
		CModule module(m_intf, i);
		modules[module.GetModuleName()] = module;
	}
	return modules;
}
const dict CDebugSymbols::GetUnloadedModules(void) const
{
	ULONG loaded = 0, unloaded = 0;
	Check(m_intf->GetNumberModules(&loaded, &unloaded));

	dict modules;
	for (ULONG i=loaded; i<loaded+unloaded; i++) {
		CModule module(m_intf, i);
		modules[module.GetModuleName()] = module;
	}
	return modules;
}

const CDebugSymbols::CModule CDebugSymbols::GetModuleByName(const std::string& name, ULONG start) const
{
	ULONG idx = 0;

	Check(m_intf->GetModuleByModuleName(name.c_str(), start, &idx, NULL));
	return CModule(m_intf, idx);
}
const CDebugSymbols::CModule CDebugSymbols::GetModuleByOffset(ULONG64 offset, ULONG start) const
{
	ULONG idx = 0;

	Check(m_intf->GetModuleByOffset(offset, start, &idx, NULL));
	return CModule(m_intf, idx);
}

const CDebugSymbols::CType CDebugSymbols::GetTypeByName(const std::string& name) const
{
	ULONG64 module; ULONG id;

	Check(m_intf->GetSymbolTypeId(name.c_str(), &id, &module));
	return CType(m_intf, module, id);
}
const CDebugSymbols::CType CDebugSymbols::GetTypeByOffset(ULONG64 offset) const
{
	ULONG64 module; ULONG id;

	Check(m_intf->GetOffsetTypeId(offset, &id, &module));
	return CType(m_intf, module, id);
}

ULONG64 CDebugSymbols::GetOffsetByName(const std::string& name) const
{
	ULONG64 offset;

	HRESULT hr = m_intf->GetOffsetByName(name.c_str(), &offset);
	Check(hr);

	// FIXME: might be a better way to do this
	if (S_FALSE == hr)
		utils::RaiseException("the symbol name was not unique and multiple symbols with that name were found.", PyExc_LookupError);

	return offset;
}

const tuple CDebugSymbols::GetNameByOffset(ULONG64 offset, LONG delta) const
{
	char szName[MAX_NAME_LENGTH];
	ULONG size = _countof(szName);
	ULONG64 displacement = 0;

	if (delta)
		Check(m_intf->GetNearNameByOffset(offset, delta, szName, size, &size, &displacement));
	else
		Check(m_intf->GetNameByOffset(offset, szName, size, &size, &displacement));

	std::string result(szName, size-1);
	return make_tuple(str(result), displacement);
}

const dict CDebugSymbols::GetSymbolOffsets(const std::string& pattern) const
{
	SymbolMatcher matcher(m_intf, pattern);

	dict symbols;

	std::string name;
	ULONG64 offset;

	while (matcher.Next(name, offset))
		symbols[name] = offset;

	return symbols;
}

const dict CDebugSymbols::GetSymbolsByName(const std::string& pattern) const
{
	CComQIPtr<IDebugSymbols3> intf(m_intf);
	ULONG count = 0;

	Check(intf->GetSymbolEntriesByName(const_cast<PSTR>(pattern.c_str()), 0, NULL, 0, &count));

	if (count == 0)
		return dict();

	// FIXME: what kind of type is DEBUG_MODULE_AND_ID and should be it in python?
	std::vector<DEBUG_MODULE_AND_ID> ids(count);
	Check(intf->GetSymbolEntriesByName(const_cast<PSTR>(pattern.c_str()), 0, &ids[0], ids.size(), &count));

	dict symbols;
	for (size_t i=0; i<ids.size(); i++) {
		CSymbol symbol(intf, ids[i]);
		symbols[symbol.GetName()] = make_tuple(symbol, 0);
	}

	return symbols;
}
const dict CDebugSymbols::GetSymbolsByOffset(ULONG64 offset) const
{
	CComQIPtr<IDebugSymbols3> intf(m_intf);

	ULONG count = 1;

	// FIXME: what kind of type is DEBUG_MODULE_AND_ID and should be it in python?
	std::vector<DEBUG_MODULE_AND_ID> ids(count);
	std::vector<ULONG64> displacements(count);

	HRESULT hr = intf->GetSymbolEntriesByOffset(offset, 0, &ids[0], &displacements[0], ids.size(), &count);
	Check(hr);

	dict symbols;
	if (count == 0)
		return symbols;

	if (S_OK != hr) {
		ids.resize(count);
		displacements.resize(count);

		Check(intf->GetSymbolEntriesByOffset(offset, 0, &ids[0], &displacements[0], ids.size(), &count));
	}

	for (size_t i=0; i<ids.size(); i++) {
		CSymbol symbol(intf, ids[i]);
		symbols[symbol.GetName()] = make_tuple(symbol, displacements[i]);
	}

	return symbols;
}

/* CDebugSymbols::CModule */
void
CDebugSymbols::CModule::Init(void)
{
	char szImageName[MAX_PATH], szModuleName[MAX_PATH], szLoadedImageName[MAX_PATH];
	ULONG nImageName = _countof(szImageName), nModuleName = _countof(szModuleName), nLoadedImageName = _countof(szLoadedImageName);

	// FIXME: should DEBUG_ANY_ID be an enumeration or python type of some kind?
	Check(m_intf->GetModuleNames(DEBUG_ANY_ID, m_base, szImageName, nImageName, &nImageName,
		szModuleName, nModuleName, &nModuleName, szLoadedImageName, nLoadedImageName, &nLoadedImageName));

	m_imageName = std::string(szImageName, nImageName-1);
	m_moduleName = std::string(szModuleName, nModuleName-1);
	m_LoadedImageName = std::string(szLoadedImageName, nLoadedImageName-1);
}

const std::string
CDebugSymbols::CModule::GetModuleNameString(ULONG which) const
{
	CComQIPtr<IDebugSymbols2> intf(m_intf);
	char szName[MAX_PATH];
	ULONG nName = _countof(szName);

	// FIXME: should DEBUG_ANY_ID be an enumeration or python type of some kind?
	Check(intf->GetModuleNameString(which, DEBUG_ANY_ID, m_base, szName, nName, &nName));
	return std::string(szName, nName-1);
}

ULONG64
CDebugSymbols::CModule::GetBase(void) const
{
	return m_base;
}

const std::string
CDebugSymbols::CModule::GetImageName(void) const
{
	// FIXME: should DEBUG_MODNAME_IMAGE be an enumeration?
	return GetModuleNameString(DEBUG_MODNAME_IMAGE);
}

const std::string
CDebugSymbols::CModule::GetModuleName(void) const
{
	// FIXME: should DEBUG_MODNAME_MODULE be a enumeration?
	return GetModuleNameString(DEBUG_MODNAME_MODULE);
}

const std::string
CDebugSymbols::CModule::GetLoadedImageName(void) const
{
	// FIXME: should DEBUG_MODNAME_LOADED_IMAGE be a enumeration?
	return GetModuleNameString(DEBUG_MODNAME_LOADED_IMAGE);
}

const std::string
CDebugSymbols::CModule::GetSymbolFileName(void) const
{
	// FIXME: should DEBUG_MODNAME_SYMBOL_FILE be a enumeration?
	return GetModuleNameString(DEBUG_MODNAME_SYMBOL_FILE);
}

const std::string
CDebugSymbols::CModule::GetMappedImageName(void) const
{
	// FIXME: should DEBUG_MODNAME_MAPPED_IMAGE be a enumeration?
	return GetModuleNameString(DEBUG_MODNAME_MAPPED_IMAGE);
}

const CDebugSymbols::CType
CDebugSymbols::CModule::GetTypeByName(const std::string& name) const
{
	ULONG id;
	Check(m_intf->GetTypeId(m_base, name.c_str(), &id));

	return CType(m_intf, m_base, id);
}

void
CDebugSymbols::CModule::Reload(void) const
{
	m_intf->Reload(GetModuleName().c_str());
}

const object
CDebugSymbols::CModule::Repr(const CModule& module)
{
	return "(Module %s @ %08x)" % make_tuple(module.GetModuleName().c_str(), module.GetBase());
}

/* CDebugSymbols::CType */
const CDebugSymbols::CModule
CDebugSymbols::CType::GetModule(void) const
{
	// FIXME: should DEBUG_ANY_ID be an enumeration or python type of some kind?
	return CModule(m_intf, DEBUG_ANY_ID, m_module);
}
ULONG
CDebugSymbols::CType::GetId(void) const
{
	return m_id;
}

const std::string
CDebugSymbols::CType::GetName(void) const
{
	char szName[MAX_NAME_LENGTH];
	ULONG size = _countof(szName);

	Check(m_intf->GetTypeName(m_module, m_id, szName, size, &size));
	return std::string(szName, size-1);
}

ULONG
CDebugSymbols::CType::GetSize(void) const
{
	ULONG size = 0;
	Check(m_intf->GetTypeSize(m_module, m_id, &size));
	return size;
}

const dict
CDebugSymbols::CType::GetFields(void) const
{
	CComQIPtr<IDebugSymbols3> intf(m_intf);

	char szName[MAX_NAME_LENGTH];
	ULONG uName, uType, uOffset;

	// FIXME: should this int for `i` be a ULONG?
	dict fields;
	for (int i = 0; ; i++) {
		HRESULT hr = intf->GetFieldName(m_module, m_id, i, szName, _countof(szName), &uName);

		if (S_OK == hr) {
			Check(intf->GetFieldTypeAndOffset(m_module, m_id, szName, &uType, &uOffset));
			fields[std::string(szName, uName - 1)] = make_tuple(CType(intf, m_module, uType), uOffset);
		}
		else if (E_INVALIDARG == hr) { // All Fields done
			break;
		}
		else {
			Check(hr);
		}
	}
	return fields;
}

const object
CDebugSymbols::CType::ReadPhysical(ULONG64 offset) const
{
	ULONG size = GetSize();
	object buffer(handle<>(::PyBuffer_New(size)));

	LPVOID data = NULL;
	Py_ssize_t len = 0;

	if (0 != ::PyObject_AsWriteBuffer(buffer.ptr(), &data, &len))
		throw_error_already_set();

	Check(m_intf->ReadTypedDataPhysical(offset, m_module, m_id, data, len, &size));
	return buffer;
}

ULONG
CDebugSymbols::CType::WritePhysical(ULONG64 offset, const object buffer) const
{
	ULONG size = 0;
	LPCVOID data = NULL;
	Py_ssize_t len = 0;

	if (0 != ::PyObject_AsReadBuffer(buffer.ptr(), &data, &len))
		throw_error_already_set();

	Check(m_intf->WriteTypedDataPhysical(offset, m_module, m_id, const_cast<LPVOID>(data), len, &size));
	return size;
}

const object
CDebugSymbols::CType::ReadVirtual(ULONG64 offset) const
{
	ULONG size = GetSize();
	object buffer(handle<>(::PyBuffer_New(size)));

	LPVOID data = NULL; Py_ssize_t len = 0;
	if (0 != ::PyObject_AsWriteBuffer(buffer.ptr(), &data, &len))
		throw_error_already_set();
	Check(m_intf->ReadTypedDataVirtual(offset, m_module, m_id, data, len, &size));
	return buffer;
}

ULONG
CDebugSymbols::CType::WriteVirtual(ULONG64 offset, const object buffer) const
{
	ULONG size = 0;
	LPCVOID data = NULL;
	Py_ssize_t len = 0;

	if (0 != ::PyObject_AsReadBuffer(buffer.ptr(), &data, &len))
		throw_error_already_set();

	Check(m_intf->WriteTypedDataVirtual(offset, m_module, m_id, const_cast<LPVOID>(data), len, &size));
	return size;
}

void
CDebugSymbols::CType::OutputPhysical(ULONG64 offset, TypeOption options, CDebugControl::OutputControl target)
{
	Check(m_intf->OutputTypedDataPhysical(static_cast<ULONG>(target), offset, m_module, m_id, static_cast<ULONG>(options)));
}

void
CDebugSymbols::CType::OutputVirtual(ULONG64 offset, TypeOption options, CDebugControl::OutputControl target)
{
	Check(m_intf->OutputTypedDataVirtual(static_cast<ULONG>(target), offset, m_module, m_id, static_cast<ULONG>(options)));
}

const object
CDebugSymbols::CType::Repr(const CType& type)
{
	return "(Type %s!%s)" % make_tuple(type.GetModule().GetModuleName().c_str(), type.GetName().c_str());
}

/* CDebugSymbols::CSymbol */
const std::string
CDebugSymbols::CSymbol::GetName(void) const
{
	char szName[MAX_NAME_LENGTH];
	ULONG size = _countof(szName);
	DEBUG_MODULE_AND_ID id = { m_entry.ModuleBase, m_entry.Id };

	Check(m_intf->GetSymbolEntryString(&id, 0, szName, size, &size));
	return std::string(szName, size-1);
}

const CDebugSymbols::CModule
CDebugSymbols::CSymbol::GetModule(void) const
{
	return CModule(m_intf, DEBUG_ANY_ID, m_entry.ModuleBase);
}

ULONG64
CDebugSymbols::CSymbol::GetModuleBase(void) const
{
	return m_entry.ModuleBase;
}

ULONG64
CDebugSymbols::CSymbol::GetId(void) const
{
	return m_entry.Id;
}

ULONG64
CDebugSymbols::CSymbol::GetOffset(void) const
{
	return m_entry.Offset;
}

ULONG
CDebugSymbols::CSymbol::GetSize(void) const
{
	return m_entry.Size;
}

ULONG
CDebugSymbols::CSymbol::GetTypeId(void) const
{
	return m_entry.TypeId;
}

ULONG
CDebugSymbols::CSymbol::GetToken(void) const
{
	return m_entry.Token;
}

ULONG
CDebugSymbols::CSymbol::GetTag(void) const
{
	return m_entry.Tag;
}

ULONG
CDebugSymbols::CSymbol::GetArg32(void) const
{
	return m_entry.Arg32;
}

ULONG64
CDebugSymbols::CSymbol::GetArg64(void) const
{
	return m_entry.Arg64;
}

const object
CDebugSymbols::CSymbol::Repr(const CSymbol& symbol)
{
	return "(Symbol %s!%s)" % make_tuple(symbol.GetModule().GetModuleName().c_str(), symbol.GetName().c_str());
}

/* CDebugSymbols::SymbolMatcher */
bool
CDebugSymbols::SymbolMatcher::Next(std::string& name, ULONG64& offset)
{
	char szName[MAX_NAME_LENGTH];
	ULONG size = _countof(szName);

	HRESULT hr = m_intf->GetNextSymbolMatch(m_handle, szName, _countof(szName), &size, &offset);

	if (SUCCEEDED(hr))
		name = std::string(szName, size-1);
	else {
		name.clear();
		offset = 0;
	}
	return S_OK == hr;
}
